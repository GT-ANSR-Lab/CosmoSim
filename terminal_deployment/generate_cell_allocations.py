import sys
from dataclasses import dataclass
import random
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon as mPolygon
from matplotlib.collections import PatchCollection

from argparse import ArgumentParser, Namespace


SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent
INPUT_ROOT = PROJECT_ROOT / "inputs"
CELLS_ROOT = INPUT_ROOT / "cells"
TERMINAL_OUTPUT_ROOT = SCRIPT_DIR / "terminals"
TERMINAL_OUTPUT_ROOT.mkdir(parents=True, exist_ok=True)
if str(PROJECT_ROOT) not in sys.path:
    sys.path.append(str(PROJECT_ROOT))

from utils.h3_compat import cell_to_boundary  # noqa: E402




def load_country_population(country_name: str, detail_level: str) -> pd.DataFrame:
    """
    Load precomputed H3 cell populations for the given country.

    The script prefers a detail-specific file (e.g., `<country>_level6.txt`) when
    the caller overrides `--detail`. Otherwise it falls back to the default
    `<country>.txt` generated by `inputs/list_cell_populations.py`.
    """
    candidates: List[Path] = []
    if detail_level and detail_level != "0":
        candidates.append(CELLS_ROOT / f"{country_name}_level{detail_level}.txt")
    candidates.append(CELLS_ROOT / f"{country_name}.txt")

    tried = []
    for candidate in candidates:
        tried.append(candidate.name)
        if candidate.exists():
            df = pd.read_csv(candidate)
            if {"h3_index", "population"} - set(df.columns):
                raise ValueError(
                    f"Cell population file {candidate} is missing required columns "
                    "'h3_index' and/or 'population'."
                )
            df = df.fillna({"population": 0})
            df["h3_index"] = df["h3_index"].astype(str)
            df["population"] = df["population"].astype(int)
            return df

    searched = ", ".join(tried) if tried else "no candidates"
    raise FileNotFoundError(
        f"No cell population file found for '{country_name}'. Checked: {searched}. "
        "Generate files via inputs/list_cell_populations.py first."
    )
    
def gcb_cells_no_cap(population_data, num_terminals, ku_capacity):
    # sort cells by population density
    sorted_cells = sorted(population_data, key=population_data.get, reverse=True)
    terminals_at_capacity = int(ku_capacity * 80)
    
    cell_terminals = {}
    num_terminals_left = num_terminals
    
    for cell in sorted_cells:
        
        cell_terminals[cell] = min(terminals_at_capacity, num_terminals_left)
        num_terminals_left -= cell_terminals[cell]

    
    while num_terminals_left > 0:
        for cell in sorted_cells:
            if num_terminals_left == 0:
                break
            cell_terminals[cell] += 1
            num_terminals_left -= 1

    return cell_terminals

def gcb_cells_with_cap(population_data, num_terminals, cap, ku_capacity):
    # sort cells by population density
    sorted_cells = sorted(population_data, key=population_data.get, reverse=True)
    terminals_at_capacity = int(ku_capacity * 80)
    
    cell_terminals = {}
    num_terminals_left = num_terminals
    
    for cell in sorted_cells:
        if population_data[cell] < cap:
            break
        cell_terminals[cell] = min(terminals_at_capacity, num_terminals_left)
        num_terminals_left -= cell_terminals[cell]

    # print(f"terminals left: {num_terminals_left}")
    # Distribute remaining terminals to cells with highest population density
    while num_terminals_left > 0:
        progress = False
        for cell in sorted_cells:
            if population_data.get(cell, 0) < cap or num_terminals_left == 0:
                break
            if cell_terminals[cell] >= terminals_at_capacity:
                continue
            cell_terminals[cell] += 1
            num_terminals_left -= 1
            progress = True
            if num_terminals_left == 0:
                break
        if not progress:
            break

    return cell_terminals

def density_cells(h3_cells, population_data, num_terminals):
    """
    Generate terminals in H3 cells proportional to population density.
    """
    total_population = sum(population_data.values())
    num_terminals_left = num_terminals
    cell_terminals = {}
    
    for cell in h3_cells:
        cell_population = population_data.get(cell, 0)
        # Calculate number of terminals for this cell
        cell_terminals[cell] = round((cell_population / total_population) * num_terminals)
        # print(f"Cell {cell} has {cell_population} population and {cell_terminals} terminals")
        num_terminals_left -= cell_terminals[cell]

    # Distribute remaining terminals to cells with highest population density
    sorted_cells = sorted(h3_cells, key=lambda cell: population_data.get(cell, 0), reverse=True)
    for cell in sorted_cells:
        if num_terminals_left == 0:
            break
        cell_terminals[cell] += 1
        num_terminals_left -= 1
        # print(f"Cell {cell} has {cell_terminals[cell]} terminals")

    return cell_terminals

def uniform_cells(h3_cells, num_terminals):
    """
    Generate terminals uniformly across H3 cells.

    Args:
        h3_cells (list): List of H3 cells.
        num_terminals (int): Number of terminals to generate.

    Returns:
        list: List of terminal data (lat, lon).
    """
    terminals_per_cell = num_terminals // len(h3_cells)
    cell_terminals = {}
    
    for cell in h3_cells:
        cell_terminals[cell] = terminals_per_cell
    
    terminals_left = num_terminals % len(h3_cells)

    # randomly distribute the remaining terminals
    for _ in range(terminals_left):
        cell = random.choice(h3_cells)
        cell_terminals[cell] += 1

    return cell_terminals

def plot_cell_heatmap(country_name, cell_terminals, ut_distribution, cap):
    
    num_terminals = sum(cell_terminals.values())
    polygons = []
    values = []

    for cell, terminals in cell_terminals.items():
        cell_boundary = cell_to_boundary(cell)

        cell_boundary = [(lon, lat) for lat, lon in cell_boundary]
        cell_polygon = mPolygon(cell_boundary)
        polygons.append(cell_polygon)
        values.append(terminals)

    # Plot the country polygon and the terminals
    fig, ax = plt.subplots()
    patch_collection = PatchCollection(polygons, cmap='Reds')
    patch_collection.set_array(values)  # Set the values for coloring
    ax.add_collection(patch_collection)

    ax.autoscale_view()
    ax.set_aspect('equal', adjustable='box')

    max_value = max(values)
    min_value = min(values)
    
    patch_collection.set_clim(vmin=0, vmax=max_value)
    plt.colorbar(patch_collection, ax=ax, label='Number of Terminals', shrink=0.4)  # Add a colorbar
    plt.tight_layout()

    if ut_distribution == "gcb" and cap:
        fname = f"cell_visualizations/{country_name}_terminals_{num_terminals}_gcb_cap_{cap}.png"
    elif ut_distribution == "gcb":
        fname = f"cell_visualizations/{country_name}_terminals_{num_terminals}_gcb_no_cap.png"
    else:
        fname = f"cell_visualizations/{country_name}_terminals_{num_terminals}_{ut_distribution}.png"

    print(f"Saving plot to {fname}")
    plt.savefig(fname)

@dataclass
class CliOptions:
    country_name: str
    detail_level: str
    num_terminals: int
    distribution: str
    gcb_mode: Optional[str] = None
    ku_capacity: float = 0.0
    cap: Optional[int] = None


def parse_cli_arguments(argv: Iterable[str]) -> CliOptions:
    parser = ArgumentParser(
        prog="generate_cell_allocations.py",
        description="Generate H3 cell allocations for user terminals."
    )
    parser.add_argument("country", help="Country name matching the shapefile directory.")
    parser.add_argument("num_terminals", type=int, help="Number of terminals to distribute.")
    parser.add_argument(
        "distribution",
        choices=["uniform", "population", "gcb"],
        help="User terminal distribution type."
    )
    parser.add_argument("gcb_mode", nargs="?", help="GCB distribution mode.")
    parser.add_argument(
        "cap",
        nargs="?",
        type=int,
        help="Population cap applied when GCB mode is 'cap'."
    )
    parser.add_argument(
        "ku_capacity",
        nargs="?",
        type=float,
        help="Ku capacity value used with the GCB distribution."
    )
    parser.add_argument(
        "--detail",
        "-d",
        default=None,
        help="Optional detail level for the shapefile (defaults to 0)."
    )
    args: Namespace = parser.parse_args(list(argv))

    if args.num_terminals <= 0:
        raise ValueError("Number of terminals must be a positive integer.")

    detail_level = args.detail if args.detail is not None else "0"

    if args.distribution == "gcb":
        if args.gcb_mode is None or args.gcb_mode not in {"no_cap", "cap"}:
            raise ValueError("Provide GCB mode ('no_cap' or 'cap').")
        if args.ku_capacity is None:
            raise ValueError("For 'gcb' distribution supply Ku capacity value.")
        if args.gcb_mode not in {"no_cap", "cap"}:
            raise ValueError("Invalid gcb mode. Use 'no_cap' or 'cap'.")
        if args.ku_capacity <= 0:
            raise ValueError("Provide a positive Ku capacity value (e.g., 1.28).")
        cap_value = args.cap
        if args.gcb_mode == "cap" and cap_value is None:
            raise ValueError("Provide cap value when using 'gcb cap'.")
        ku_capacity = args.ku_capacity
    else:
        cap_value = None
        if args.gcb_mode is not None or args.ku_capacity is not None or args.cap is not None:
            raise ValueError("GCB specific arguments are only valid when distribution is 'gcb'.")
        ku_capacity = 0.0

    return CliOptions(
        country_name=args.country,
        detail_level=detail_level,
        num_terminals=args.num_terminals,
        distribution=args.distribution,
        gcb_mode=args.gcb_mode,
        ku_capacity=ku_capacity or 0.0,
        cap=cap_value,
    )


def prepare_country_cells(options: CliOptions) -> Tuple[List[str], Dict[str, int], List[str]]:
    population_df = load_country_population(options.country_name, options.detail_level)
    population_series = population_df.set_index("h3_index")["population"]

    zero_population_cells = population_series[population_series == 0].index.tolist()
    positive_population_series = population_series[population_series > 0]
    positive_population_cells = positive_population_series.index.tolist()
    trimmed_population_data = positive_population_series.to_dict()

    return positive_population_cells, trimmed_population_data, zero_population_cells


def build_output_filename(options: CliOptions) -> str:
    if options.distribution == "gcb" and options.gcb_mode == "cap":
        return f"cells_{options.country_name}_{options.detail_level}_{options.num_terminals}_gcb_cap_{options.cap}_{options.ku_capacity}.txt"
    if options.distribution == "gcb":
        return f"cells_{options.country_name}_{options.detail_level}_{options.num_terminals}_gcb_no_cap_{options.ku_capacity}.txt"
    return f"cells_{options.country_name}_{options.detail_level}_{options.num_terminals}_{options.distribution}.txt"


def allocate_terminals(
    options: CliOptions,
    populated_cells: List[str],
    population_data: Dict[str, int],
    zero_population_cells: List[str],
) -> Dict[str, int]:

    if options.distribution == "uniform":
        return uniform_cells(populated_cells + zero_population_cells, options.num_terminals)

    if options.distribution == "population":
        return density_cells(populated_cells, population_data, options.num_terminals)

    if options.gcb_mode == "cap":
        return gcb_cells_with_cap(
            population_data,
            options.num_terminals,
            options.cap,
            options.ku_capacity,
        )

    return gcb_cells_no_cap(
        population_data,
        options.num_terminals,
        options.ku_capacity,
    )


def write_cell_allocations(output_path: Path, cell_terminals: Dict[str, int]) -> None:
    with open(output_path, "w") as f:
        for cell, terminals in cell_terminals.items():
            line = "{},{}\n".format(cell, terminals)
            f.write(line)


def main(argv: Optional[Iterable[str]] = None) -> None:
    # Run with: python generate_cell_allocations.py <country> <num_terminals> <distribution> [options]
    # Optional detail override: --detail <level>
    # Supported countries currently are ghana, kenya, malaysia, tonga, southafrica
    # ut_distribution can be "uniform", "population", or "gcb"
    argv = sys.argv[1:] if argv is None else list(argv)

    try:
        options = parse_cli_arguments(argv)
    except ValueError as error:
        print(error)
        return

    populated_cells, population_data, zero_population_cells = prepare_country_cells(options)

    if options.distribution == "gcb" and options.gcb_mode == "cap":
        max_pop = max(population_data.values(), default=0)
        if options.cap > max_pop:
            print(f"Cap {options.cap} is greater than the maximum population {max_pop}.")
            return

    # print(f"{len(populated_cells)} H3 cells remain after excluding those with zero population")
    cell_terminals = allocate_terminals(
        options,
        populated_cells,
        population_data,
        zero_population_cells,
    )

    for zero_pop_cell in zero_population_cells:
        cell_terminals[zero_pop_cell] = 0

    output_path = TERMINAL_OUTPUT_ROOT / build_output_filename(options)
    write_cell_allocations(output_path, cell_terminals)
    print(f"Saved terminal mapping to {output_path}")

    # Plot results
    # plot_cell_heatmap(country_name, cell_terminals, ut_distribution, options.cap)
    

if __name__ == "__main__":
    main()
